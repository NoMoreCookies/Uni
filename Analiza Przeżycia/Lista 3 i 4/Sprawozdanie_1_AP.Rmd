---
title: "Sprawozdanie 1"
subtitle: "Analiza przeżycia"
author: "Marta Stankiewicz \n(282244)"
header-includes:
   - \usepackage[OT4]{polski}
   - \usepackage[utf8]{inputenc}
   - \usepackage{graphicx}
   - \usepackage{float}
output: 
  pdf_document:
    toc: true
    fig_caption: true
    fig_width: 5 
    fig_height: 4 
    number_sections: true
fontsize: 12pt 
lof: true
lot: true
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
knitr::opts_chunk$set(fig.pos = "H", out.extra ='', fig.align = "center")

```


# Lista 3

## Zadanie 1a

```{r, echo=FALSE}

X_A <- c(0.03345514, 0.08656403, 0.08799947, 0.24385821, 0.27755032,
         0.40787247, 0.58825664, 0.64125620, 0.90679161, 0.94222208, rep(1,10))
X_B <- c(0.03788958, 0.12207257, 0.20319983, 0.24474299, 0.30492413,
         0.34224462, 0.42950144, 0.44484582, 0.63805066, 0.69119721, rep(1, 10))
t <- 1
n <- 20
R_A <- sum(X_A < t)
R_B <- sum(X_B < t) 
T_A <- sum(X_A[1:10]) + t*(n-R_A)
T_B <- sum(X_B[1:10]) + t*(n-R_B)

theta_hat_A <- R_A / T_A
theta_hat_B <- R_B / T_B

theta_wave <- - log(1-R_A/n)/t

mi_hat_A <- 1/theta_hat_A
mi_hat_B <- 1/theta_hat_B
mi_wave <- 1/theta_wave

```

Na podstawie danych opisanych w zadaniu 3 z listy 2, przyjmując, że są one realizacjami zmiennych z rozkładu wykładniczego można wyznaczyć oszacowania największej wiarogodności średniego czasu do remisji choroby dla pacjentów leczonych lekiem A oraz pacjentów leczonych lekiem B. W tym celu skorzystano ze wzorów podanych na Wykładzie 3:

$$
\hat{\vartheta} = \frac{R}{T_1} \quad
$$
gdzie

$$
T_1 = \sum_{i=1}^{R} X_{(i)} + t_0 (n - R)
$$
gdzie zmienna losowa $R$ jest losową liczbą obserwacji niecenzurowanych (kompletnych) w przedziale $(0, t_0]$.
Oszacowanie NW średniego czasu do remisji choroby pacjentów leczonych lekiem A wynosi *`r round(theta_hat_A, 4)`* natomiast oszacowanie to w przypadku leku B wynosi *`r round(theta_hat_B, 4)`*



## Zadanie 1b

```{r, echo=FALSE}
library(binom)
T.L.1.A <- binom.confint(R_A, n, methods = 'exact', conf.level = 1-0.05)$lower
T.U.1.A <- binom.confint(R_A, n, methods = 'exact', conf.level = 1-0.05)$upper

T.L.A1 <- - log(1-T.L.1.A)/t
T.U.A1 <- - log(1-T.U.1.A)/t

upp_A_1 <- 1/T.L.A1
low_A_1 <- 1/T.U.A1

T.L.2.A <- binom.confint(R_A, n, methods = 'exact', conf.level = 1-0.01)$lower
T.U.2.A <- binom.confint(R_A, n, methods = 'exact', conf.level = 1-0.01)$upper

T.L.A2 <- - log(1-T.L.2.A)/t
T.U.A2 <- - log(1-T.U.2.A)/t

upp_A_2 <- 1/T.L.A2
low_A_2 <- 1/T.U.A2

T.L.1.B <- binom.confint(R_B, n, methods = 'exact', conf.level = 1-0.05)$lower
T.U.1.B <- binom.confint(R_B, n, methods = 'exact', conf.level = 1-0.05)$upper

T.L.B1 <- - log(1-T.L.1.B)/t
T.U.B1 <- - log(1-T.U.1.B)/t

upp_B_1 <- 1/T.L.B1
low_B_1 <- 1/T.U.B1

T.L.2.B <- binom.confint(R_B, n, methods = 'exact', conf.level = 1-0.01)$lower
T.U.2.B <- binom.confint(R_B, n, methods = 'exact', conf.level = 1-0.01)$upper

T.L.B2 <- - log(1-T.L.2.B)/t
T.U.B2 <- - log(1-T.U.2.B)/t

upp_B_2 <- 1/T.L.B2
low_B_2 <- 1/T.U.B2

```

```{r results='asis', echo=FALSE}
library(knitr)

tabela <- data.frame(
  Lek = c("A", "A", "B", "B"),
  Alpha = c(0.05, 0.01, 0.05, 0.01),     
  `Realizacja przedziału ufności ` = c(
    sprintf("[%.4f, %.4f]", low_A_1, upp_A_1),
    sprintf("[%.4f, %.4f]", low_A_2, upp_A_2),
    sprintf("[%.4f, %.4f]", low_B_1, upp_B_1),
    sprintf("[%.4f, %.4f]", low_B_2, upp_B_2)
  ) )

kable(tabela, caption = "Realizacja Przedziału ufności dla średniego czasu do remisji choroby",
      digits = 4, align = "c")
```

## Zadanie 2

```{r}
fun <- function(X, m, n, alpha) {
  Xs <- sort(X)
  T2 <- sum(Xs[1:m]) + (n - m)*Xs[m]
  theta.hat <- m/T2
  mi.hat <- 1/theta.hat
  
  q.m.1 <- qgamma(alpha / 2, shape = m, rate = m)
  q.m.2 <- qgamma(1 - alpha / 2, shape = m, rate = m)
  
  T.L <- m*q.m.1/T2
  T.U <- m*q.m.2/T2
  
  return(list(
    theta.hat = theta.hat,
    mi.hat = mi.hat,
    TL = T.L, TU = T.U
  ))
}


```


```{r, results='asis', echo=FALSE}
library(knitr)

A_al1 <- fun(X_A, 10, 20, 0.05)
A_al2 <- fun(X_A, 10, 20, 0.01)
B_al1 <- fun(X_B, 10, 20, 0.05)
B_al2 <- fun(X_B, 10, 20, 0.01)

results <- data.frame(
  Lek = rep(c("A", "B"), each = 2),
  alpha = rep(c(0.05, 0.01), times = 2),
  theta_hat = c(A_al1$theta.hat, A_al2$theta.hat, B_al1$theta.hat, B_al2$theta.hat),
  mu_hat = c(A_al1$mi.hat, A_al2$mi.hat, B_al1$mi.hat, B_al2$mi.hat),
  T_L = c(A_al1$TL, A_al2$TL, B_al1$TL, B_al2$TL),
  T_U = c(A_al1$TU, A_al2$TU, B_al1$TU, B_al2$TU)
)

results[,3:6] <- lapply(results[,3:6], function(x) round(x, 4))


kable(results, caption = "Szacunki parametrów $\\hat{\\theta}$ i $\\hat{\\mu}$ oraz przedziały ufności [$TL$, $TU$] dla leków A i B", col.names = c("Lek", "$\\alpha$", "$\\hat{\\theta}$", "$\\hat{\\mu}$", "$T_L$", "$T_U$"))

```

## Zadanie 3

```{r}
M <- 10000
theta <- 1
t.values <- c(0.5, 1, 2)
n.values <- c(10, 30)

gen1 <- function(n, alpha=1, lambda=theta, t0){
  y <- runif(n)
  x <- - (1/lambda)*log(1- y^(1/alpha))
  
  delta <- ifelse(x <= t0, 1, 0)
  x_obs <- pmin(x, t0)
  
  return(data.frame(x = x_obs, delta = delta))
}

symulacja <- function(n, t0, theta){
  repeat {
    X <- gen1(n, t0=t0, lambda=theta)
    R <- sum(X$delta)
    if (R < n) break  # akceptujemy tylko próby, gdzie jest cenzurowanie
  }
  T1 <- sum(X$x[which(X$delta ==1)]) + t0*(n - R)
  
  theta.hat <- R/T1
  theta.wave <- - log(1 - R/n)/t0
  
  return(c(theta.hat, theta.wave))
}

results <- data.frame(
  n = numeric(),
  t0 = numeric(),
  Bias_hat = numeric(),
  MSE_hat = numeric(),
  Bias_wave = numeric(),
  MSE_wave = numeric()
)

for (n in n.values) {
  for (t0 in t.values) {
    
    est <- replicate(M, symulacja(n, t0, theta))
    
    theta.hat <- est[1, ]
    theta.wave <- est[2, ]
    
    bias.hat <- mean(theta.hat - theta)
    mse.hat  <- mean((theta.hat - theta)^2)
    
    bias.wave <- mean(theta.wave - theta)
    mse.wave  <- mean((theta.wave - theta)^2)
    
   
    results <- rbind(results, data.frame(
      n = n,
      t0 = t0,
      Bias_hat = bias.hat,
      MSE_hat = mse.hat,
      Bias_wave = bias.wave,
      MSE_wave = mse.wave
    ))
  }
}

kable(results)


```

# Lista 4

## Zadanie 1

```{r p-value}
wart_poz_kryt <- function(r, s, n, t0, theta0, rodzaj = "two.sided"){
  
  theta_hat <- r /(s + t0*(n-r))

  
  L <- function(theta){
    L <- (theta^r)*exp(-theta*(s + t0*(n-r)))
    return(L)
  }
  
  L_hat <- L(theta_hat)
  L_theta0 <- L(theta0)
  
  
  if (rodzaj=="two.sided"){
    lambda_obs <- L_theta0 / L_hat # funkcja osiąga sup dla est. MLE
  } else if (rodzaj == "less") {
    if (theta_hat < theta0){
      lambda_obs <- L_theta0 / L_hat 
    } else {
      lambda_obs <- 1
    }
  } else {
    if (theta_hat > theta0){
      lambda_obs <- L_theta0 / L_hat 
    } else {
      lambda_obs <- 1
    }
  }
  
  p_value <-1 - pchisq(-2*log(lambda_obs), df = 1)
  
  return (p_value)
  
}

```

## Zadanie 2

```{r moc_rozmiar, cache=TRUE}
M <- 10000
theta0 <- 1/2
n <- c(20,50)
t0 <- 2
theta <- c(0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.5, 2)

gen1 <- function(n, alpha=1, lambda=theta, t0){
  y <- runif(n)
  x <- - (1/lambda)*log(1- y^(1/alpha))
  
  delta <- ifelse(x <= t0, 1, 0)
  x_obs <- pmin(x, t0)
  
  return(data.frame(x = x_obs, delta = delta))
}


wyniki <- list()

for (n in n) {
  moc <- numeric(length(theta))
  p_val <- numeric(M)

for (k in seq_along(theta)){
  lambda <- theta[k]
  
  for (j in 1:M){
    x_wylos <- gen1(n=n, lambda=lambda, t0 = t0)
    x_obs <- x_wylos$x
    r <- sum(x_wylos$delta)
    s <- sum(x_wylos$x[x_wylos$delta==1])
    p_val[j] <- wart_poz_kryt(r=r, s=s, n=n, t0=t0, theta0=theta0, rodzaj = "two.sided")
  }
  moc[k] <- 1/M * sum(p_val[1:M]<0.05) 
}
  p_val_theta0 <- numeric(M)
  for (j in 1:M){
    x_wylos <- gen1(n = n, lambda = theta0, t0 = t0)
    r <- sum(x_wylos$delta)
    s <- sum(x_wylos$x[x_wylos$delta == 1])
    p_val_theta0[j] <- wart_poz_kryt(r = r, s = s, n = n, t0 = t0, theta0 = theta0, rodzaj = "two.sided")
  }
  
  rozmiar_hat <- mean(p_val_theta0 < 0.05)
  
  wyniki[[paste0("n=", n)]] <- data.frame(theta = theta, moc = moc)
}


```

```{r tabela_mocy, echo=FALSE}
library(dplyr)
tabela_mocy <- wyniki[["n=20"]] %>%
  rename(moc_n20 = moc) %>%
  left_join(
    wyniki[["n=50"]] %>% rename(moc_n50 = moc),
    by = "theta"
  )

tabela_mocy <- tabela_mocy %>%
  mutate(
    moc_n20 = round(moc_n20, 4),
    moc_n50 = round(moc_n50, 4)
  )

kable(
  tabela_mocy,
  caption = "Porównanie mocy testu dla różnych wartości theta i liczebności prób (n = 20, 50)",
  col.names = c("Theta", "Moc (n = 20)", "Moc (n = 50)"), align = "c")


```


## Zadanie 3

```{r weryf_hipotezy}
czasy_A <- c(0.03345514, 0.08656403, 0.08799947, 0.24385821, 0.27755032,
             0.40787247, 0.58825664, 0.64125620, 0.90679161, 0.94222208, rep(1, 10))

czasy_B <- c(0.03788958, 0.12207257, 0.20319983, 0.24474299, 0.30492413,
             0.34224462, 0.42950144, 0.44484582, 0.63805066, 0.69119721, rep(1, 10))

s_A <- sum(czasy_A[1:10])
r <- 10
s_B <- sum(czasy_B[1:10])
n <- 20
t0 <- 1
theta0 <- 1

p_wart_A <- wart_poz_kryt(r=r, s=s_A, n=n, t0=t0, theta0=theta0, rodzaj="two.sided")
p_wart_B <- wart_poz_kryt(r=r, s=s_B, n=n, t0=t0, theta0=theta0, rodzaj="two.sided")
p_wart_A
p_wart_B

```